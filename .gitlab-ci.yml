variables:
    # The host for the test SGame instance
    SGAME_HOST: "localhost"
    # The port for the test SGame instance
    SGAME_PORT: "5000"

stages:
    - build
    - test

# Build stage: build the C# SGame executable
build:
    stage: build
    before_script:
        # Before building: restore C# dependencies for SGame
        - dotnet restore SGame
    script:
        - dotnet build SGame

# Test stage
test:
    stage: test
    before_script:
        # Start an instance of the SGame server in the background (redirect stdout->stderr; sleep a bit for it to init)
        # Store the PID of the background process in a file (SGame.pid) to know what process to kill after.
        # (See issue #33 on why this is needed)
        - cd ${CI_PROJECT_DIR}
        - rm -f SGame.pid
        - dotnet run --project SGame -- --host ${SGAME_HOST} --port ${SGAME_PORT} 1>&2 &
        - echo $! > SGame.pid
        - sleep 5
    script:
        # Run automated tests via pytest
        - cd ${CI_PROJECT_DIR}/tests
        - pytest *.py --sgame ${CI_PROJECT_DIR}/SGame --host ${SGAME_HOST} --port ${SGAME_PORT}
    after_script:
        # Kill the background process in any case (tests succeeded or failure)
        # (See issue #33; otherwise GitLab will stall until timeout because the SGame process in the background won't terminate!)
        # First try to exit gracefully...
        - curl -X POST -d "exit" "http://${SGAME_HOST}:${SGAME_PORT}/exit" || echo "curl failed to POST exit command"
        - sleep 2
        # ...then use brute force if the server still hasn't terminated
        - SGAME_PID=$(cat SGame.pid)
        - echo "Kill ${SGAME_PID}"
        - pkill -KILL ${SGAME_PID} || echo "Server already stopped"
